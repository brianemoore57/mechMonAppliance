
Building on the Debian Distribution
(Linux beaglebone 3.8.13-bone47 #1 SMP Fri Apr 11 01:36:09 UTC 2014 armv7l GNU/Linux)

We will probably not develop any more using ethernet over USB connection, as it requires a lot of effort only to be
undone. Using the wired or Wi-Fi (Logic Supply's UWN200 USB external adapter with 4" antenna) connections represents
the installation environment best during development. The ethernet over USB may be used for installation during early
development. A mature product will be installed via flash into eprom from microSD. The following assumes a Cygwin or
linux environment on the company laptop/server.

FIRMWARE PREPARATION
The preparation of a new beaglebone black (without cape) requires the following steps:

1. Connect the 5V 2A supply to the beaglebone. Observe the blue LEDs as the boot sequence exercises them. Once booted
   fully, the USB0 LED flashes continuously, about once per second.

2. Flash the upgraded OS if required from the micro SD. Insert the SD and reboot the board while holding down
   the small button on the board itself. This boots from the SD and transfers it onto the onboard Flash ROM.
   Note that we can eventually create our flash image with ALL customization on it.

3. Connect to it via USB.

4. Assigning a static IP address if required/desired. Actual field installs will be static. The connman tool is
   used on Angstrom, or modify the boot.sh as required. This can and should be scripted as the default address is
   192.168.7.2. A different static IP may be desired in the lab, and a final IP will be assigned in the field. An
   explanation is at https://www.howtoforge.com/debian-static-ip-address.

5. Execute install.sh script on the company laptop/server which copies a complete project directory as
    /usr/local/mechMon onto the BBB, including the following:
     a. build.sh - change to a grunt deploy process on company laptop/server
     b. boot.sh - must be configured to run on bootup. Note we have NO BIOS, so date/time DNS, etc must be set on bootup
     c. startup.sh - launches server
     d. shutdown.sh - kills server
     e. company ssh private key(s) so unit can communicate with company cloud server and service technician.

6. Execute /usr/local/mecMon/build.sh - It will make directories, set permissions, etc. It may upgrade the
7. If a cape is to be used, i.e. CBB-Relay cape, a .dtbo file must be insstalled into /var/lib
8. Close all login methods other than ssh private keys (no password login).
9. Test
      a. test that date/time are set
      b. check ifconfig that address is as desired
      b. check that ping 8.8.8.8 works (route is good)
      c. check ping www.google.com works (dns is good)
      d. check 'ps aux | grep node server.js 2000' returns a value (Note another node instance is probably running)

INITIAL DESIGN DECISIONS

The installed node is version 0.10.2, and is required for Express, etc. The angstrom distribution has node v~0.8.02
and will not run the latest Express. Our server will use the built-in service tools to take server up/down, auto-start
(on boot) by file location, etc. The cloud9 environment is all setup to run on port 3000, and is a service that
auto-starts on boot. We will disable that one. For now, we will use port 2000.

BOOTING

The booting requirements beyond what the platform does by itself, include making sure all pins and CAPE devices
are in a known state. So somewhere in our boot process, we need to set them. Since the boot script itself is a BASH
script, I prefer to set the pins with javascript when the server is launched. You will see code in server.js that
initializes some of the pins, but must be expanded.

ENGINEERING TIPS


========================================================================
Use of ssh keys, here is github's literature:
========================================================================
check for public keys....
ls -al ~/.ssh
# Lists the files in your .ssh directory, if they exist
Check the directory listing to see if you already have a public SSH key. The default public key file names are:

id_dsa.pub
id_ecdsa.pub
id_ed25519.pub
id_rsa.pub

Step 2: Generate a new SSH key

To generate a new SSH key, copy and paste the text below, making sure to substitute in your email address. The default settings are preferred, so when you're prompted to "Enter a file in which to save the key", just press Enter to continue.

 ssh-keygen -t rsa -C "your_email@example.com"
# Creates a new ssh key, using the provided email as a label
# Generating public/private rsa key pair.
# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]
Next, you'll be asked to enter a passphrase.

Tip: We strongly recommend a very good, secure passphrase. For more information, see Working with SSH key passphrases.
# Enter passphrase (empty for no passphrase): [Type a passphrase]
# Enter same passphrase again: [Type passphrase again]
Which should give you something like this:

 # Your identification has been saved in /c/Users/you/.ssh/id_rsa.
# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
# The key fingerprint is:
# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
Then add your new key to the ssh-agent:

 # start the ssh-agent in the background
ssh-agent -s
# Agent pid 59566
ssh-add ~/.ssh/id_rsa

Step 3: Add your SSH key to your account

Run the following command to copy the key to your clipboard. Keep in mind that your key may also be named id_dsa.pub,
 id_ecdsa.pub or id_ed25519.pub.

$ clip < ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard

Alternatively, using your favorite text editor, you can open the public key file and copy the contents of the file manually.

Now that you have the key copied, it's time to add it to GitHub:

In the top right corner of any page, click .

In the user settings sidebar, click SSH keys.

Click Add SSH key.

In the Title field, add a descriptive label for the new key. For example, if you're using a personal Mac, you might call this key "Personal MacBook Air".
The key fieldPaste your key into the "Key" field.
The Add key buttonClick Add key.
Confirm the action by entering your GitHub password.

Step 4: Test everything out

To make sure everything is working, you'll now try SSHing to GitHub. When you do this, you will be asked to
authenticate this action using your password, which was the passphrase you created earlier.

Open up your Git Bash and type:

ssh -T git@github.com
# Attempts to ssh to GitHub
You may see this warning:

# The authenticity of host 'github.com (207.97.227.239)' can't be established.
# RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
# Are you sure you want to continue connecting (yes/no)?

Don't worry! This is supposed to happen. Verify that the fingerprint in your terminal matches the one we've provided
 up above, and then type "yes."

# Hi username! You've successfully authenticated, but GitHub does not
# provide shell access.

If that username is yours, you've successfully set up your SSH key! Don't worry about the "shell access" thing, you
 don't want that anyway.

If you receive a message about "access denied," you can read these instructions for diagnosing the issue.

If you're switching from HTTPS to SSH, you'll now need to update your remote repository URLs. For more information,
 see Changing a remote's URL.
====================================================================================================
USING SSH PASSPHRASEs
=====================================================================================================
Working with SSH key passphrases

This article will walk you through the process of securing your SSH keys and configuring an authentication agent so
that you won't have to re-enter your passphrase every time you use your keys.

Why do I need a passphrase?

Passwords aren't very secure. If you use one that's easy to remember, it's also easier to guess or brute-force
(try many options until one works). If you use one that's random, it's hard to remember, and thus you're more inclined
 to write it down. Both of these are Very Bad Things.

This is why you're using SSH keys. Of course, using a key without a passphrase is basically the same as writing down a
random password: anyone who gains access to your computer has gained access to every system you use that key with. This
 is also a Very Bad Thing. The solution is to add a passphrase to the SSH key for an extra layer of security.

But I don't want to enter a long passphrase every time I use the key!

Neither do I! Thankfully, there's a nifty little tool called ssh-agent that can securely save your passphrase, so you
don't have to re-enter it. If you're on OS X Leopard or later your keys can be saved in the system's keychain to make
 your life even easier. Most Linux installations will automatically start ssh-agent for you when you log in.

Adding or changing a passphrase

You can change the passphrase for an existing private key without regenerating the keypair. Just type the following
command:

ssh-keygen -p
# Start the SSH key creation process
# Enter file in which the key is (/Users/you/.ssh/id_rsa): [Hit enter]
# Key has comment '/Users/you/.ssh/id_rsa'
# Enter new passphrase (empty for no passphrase): [Type new passphrase]
# Enter same passphrase again: [One more time for luck]
# Your identification has been saved with the new passphrase.
If your key already has a passphrase, you will be prompted to enter it before you can change to a new passphrase.

Auto-launching ssh-agent on msysgit

ssh-agent is a tool that provides a secure way of storing and using your SSH keys.

You can run ssh-agent automatically when you open bash. Copy the following lines and paste them into your ~/.profile
or ~/.bashrc file:

# Note: ~/.ssh/environment should not be used, as it
#       already has a different purpose in SSH.

env=~/.ssh/agent.env

# Note: Don't bother checking SSH_AGENT_PID. It's not used
#       by SSH itself, and it might even be incorrect
#       (for example, when using agent-forwarding over SSH).

agent_is_running() {
    if [ "$SSH_AUTH_SOCK" ]; then
        # ssh-add returns:
        #   0 = agent running, has keys
        #   1 = agent running, no keys
        #   2 = agent not running
        ssh-add -l >/dev/null 2>&1 || [ $? -eq 1 ]
    else
        false
    fi
}

agent_has_keys() {
    ssh-add -l >/dev/null 2>&1
}

agent_load_env() {
    . "$env" >/dev/null
}

agent_start() {
    (umask 077; ssh-agent >"$env")
    . "$env" >/dev/null
}

if ! agent_is_running; then
    agent_load_env
fi

# if your keys are not stored in ~/.ssh/id_rsa.pub or ~/.ssh/id_dsa.pub, you'll need
# to paste the proper path after ssh-add
if ! agent_is_running; then
    agent_start
    ssh-add
elif ! agent_has_keys; then
    ssh-add
fi

unset env
Tip: If your private keys are not stored in ~/.ssh/id_rsa or ~/.ssh/id_dsa, you must add their paths with the ssh-add
command so that your SSH authentication agent knows where to find them. For example:

ssh-add ~/.my_other_ssh/id_rsa
Now, when you first run Git Bash, you are prompted for your passphrase:

# Initializing new SSH agent...
# succeeded
# Enter passphrase for /c/Users/you/.ssh/id_rsa:
# Identity added: /c/Users/you/.ssh/id_rsa (/c/Users/you/.ssh/id_rsa)
# Welcome to Git (version 1.6.0.2-preview20080923)
>
# Run 'git help git' to display the help index.
# Run 'git help ' to display help for specific commands.

=====================================================================================================

One problem encountered is the loss of access to the beaglebone by corrupting the ssh configuration, then needing
another means of access. Of course a production installation should be of lesser concern, but much development
time lost over this problem. See https://wiki.debian.org/NetworkConfiguration



Regarding node.js, for these types of applications, you may not feel your ajax call, especially a POST,
needs return any value to set a bit. But node requires you to return a value, even from a POST [although
you can use res.send(undefined)]. So you might as well return an 'OK' text string. It is easier to diagnose.
You actually need that acknowledgement, and using the 'success' method in the AJAX call, you can change the button
color, etc to update 'state' in the GUI.

Procedure for setting static-ip is not finalized, some references follow:
   pertinent file: /etc/network/interfaces devian tools:
   http://inspire.logicsupply.com/2014/07/beaglebone-wifi-installation.html (best method) wicd-curses tool (wi-fi)
   https://www.howtoforge.com/debian-static-ip-address
   http://sheldondwill.wordpress.com/2013/12/14/beaglebone-black-ubuntu-change-to-static-ip-address/
   http://www.embeddedhobbyist.com/debian-tips/beaglebone-black/beaglebone-black-init-scripts-default-gatewayand-ntpdate/

Excellent assistance for industrial applications:
    http://inspire.logicsupply.com/2014/07/beaglebone-getting-ready-for-industrial.html

Setting app up as a service: http://unix.stackexchange.com/questions/47695/how-to-write-startup-script-for-systemd
   https://savanne.be/articles/deploying-node-js-with-systemd/
   also https://coreos.com/docs/launching-containers/launching/getting-started-with-systemd/ - BEST!!
    and http://www.linux.com/learn/tutorials/788613-understanding-and-using-systemd
by creating a systemd unit file. Note the path to node must of couse be correct. For
information regarding systemd vs init.d:    http://www.tecmint.com/systemd-replaces-init-in-linux/
   also https://wiki.debian.org/Debate/initsystem/systemd

Note that most current systems currently implement both for availibility to apps.
In /etc/systemd/system create a file       see /etc/systemd/system/syslog.service for an example
named mechMon.service
============================
[Unit]
Description=mechMon
ConditionPathExists=|/usr/local/mechMon
[Service]
ExecStart=/usr/local/mechMon/startup.sh
      ExecStop=/usr/local/mechMon/shutdown.sh  if we werent using "Restart=always"
      Type=oneshot would also be required
Restart=always
StandardOutput=syslog
SyslogIdentifier=mechMon
User-nobody
Group=nobody
Environment=PATH=/opt/nodejs/v0.10.25.bin:/usr/bin:/usr/local/bin
Environment=NODE_ENV=development     or  production

[Install]
WantedBy=multi-user.target
==============================
These are the commands you're probably going to use the most:

# systemctl start [name.service]
# systemctl stop [name.service]
# systemctl restart [name.service]
# systemctl reload [name.service]
$ systemctl status [name.service]
# systemctl is-active [name.service]
$ systemctl list-units --type service --all
systemd has 12 unit types. .service is system services, and is default - the suffix is not really required
$ systemd-analyze blame  You can run this to find out how long it takes to boot all programs and services.
 systemctl list-unit-files --type=service displays the status of all installed services that have init scripts


The familiar /etc/inittab is no more. Instead, we have a /etc/systemd/system/ directory chock-full of symlinks to
files in /usr/lib/systemd/system/. /usr/lib/systemd/system/ contains init scripts; to start a service at boot
it must be linked to /etc/systemd/system/. The systemctl command does this for you when you enable a new service,
like this example:
$ systemctl enable ntp.service
ln -s '/usr/lib/systemd/system/ntp.service' '/etc/systemd/system/multi-user.target.wants/ntp.service'

This way, other scripts, perhaps SysV scripts that need this service can find it. So "systemctl enable myapp.service"
is required. Then  "systemctl status myapp.service" will show it as enabled. (This does not mean running BTW)
There are three possible states for a service: enabled or disabled, and static. Enabled means it has a symlink in a
.wants directory. Disabled means it does not. Static means the service is missing the [Install] section in its init
script, so you cannot enable or disable it. Static services are usually dependencies of other services, and are
controlled automatically. You can see this in the ClamAV example, as clamd@.service is a dependency of
clamd@scan.service, and it runs only when clamd@scan.service runs.

None of these states tell you if a service is running. The ps command will tell you, or use systemctl to get more
detailed information:

  $ systemctl status bluetooth.service
  bluetooth.service - Bluetooth service
     Loaded: loaded (/usr/lib.systemd/system/bluetooth.service; enabled)
     Active: active (running) since Thu 2014-09-14 6:40:11 PDT
    Main PID: 4964 (bluetoothd)
     CGroup: /system.slice/bluetooth.service
             |_4964 /usr/bin/bluetoothd -n
  systemctl tells you everything you want to know, if you know how to ask

Note the environment variable NODE_ENV=development above causes node to turn off caching among other things,
(but not your browser). Changing the environment variable NODE_ENV=production turns them back on.
******************************************************************************************************
Just for posterity, the procedure to upgrade node.js from scratch on the angstrom distro would follow the following
procedure:

Step 1: Prerequisites - here's what we will need, not how we will build it (we will use flash image)
We will need a compiler to compile the node source. The build requires python for the configuration scripts and
gcc for the actual code.
# opkg update
# opkg upgrade - will take hours
# opkg install ntp
$ vim /etc/ntp.conf
and edit similar to the following
  # NTP Configuration File
  # The driftfile must remain in a place specific to this machine
  driftfile /etc/ntp.drift
  logfile /var/log/ntpd.log
  # NTP Servers for USA
  server 0.us.pool.ntp.org
  server 1.us.pool.ntp.org
  server 2.us.pool.ntp.org
  server 3.us.pool.ntp.org
  # Using local hardware clock as fallback
  # Disable this when using ntpd -q -g -x as ntpdate or it will sync to itself
  # server 127.127.1.0
  # fudge 127.127.1.0 stratum 14
  # Defining a default security setting
  restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap

Now we need to set again our local zone. To check the available ones, just look into the
 /usr/share/zoneinfo/ directory.

$ rm /etc/localtime
$ ln -s /usr/share/zoneinfo/Europe/Paris /etc/localtime
And now we are going to configure the ntp service.

$ systemctl enable ntpdate.service
$ systemctl enable ntpd.service
And finally we are going to edit the “ntpdate.service”:

$ vim /lib/systemd/system/ntpdate.service
And replace this line:
  ExecStart=/usr/bin/ntpdate-sync silent
With these two:
  ExecStart=/usr/bin/ntpd -q -g -x
  ExecStart=/sbin/hwclock --systohc
Restart the board to allow the “ntp” service to start.

-------------------------------------------
# apt-get install python
# apt-get install build-essential


Step 2: Download Node Source
Download the latest source code from the node.js website. At the time of writing it is version 0.10.5 so
adjust this to the desired version. We will unpack it in the current directory. Specify the -C <path> option to
extract it elsewhere.

# wget http://nodejs.org/dist/v0.10.5/node-v0.10.5.tar.gz
# tar xzvf node-v0.10.5.tar.gz


Step 3: Configure
At the time of this writing, there is a problem with the Google V8 Snapshot feature causing node to
segmentation fault. Snapshotting helps node start faster and is not a big-deal feature; we will just compile
without it.

# cd node-v0.10.5
# ./configure --without-snapshot
Result:

{ 'target_defaults': { 'cflags': [],
                       'default_configuration': 'Release',
                       'defines': [],
                       'include_dirs': [],
                       'libraries': []},
  'variables': { 'arm_fpu': 'vfpv3',
                 'arm_neon': 0,
                 'armv7': 1,
                 'clang': 0,
                 'gcc_version': 47,
                 'host_arch': 'arm',
                 'node_install_npm': 'true',
                 'node_prefix': '',
                 'node_shared_cares': 'false',
                 'node_shared_http_parser': 'false',
                 'node_shared_libuv': 'false',
                 'node_shared_openssl': 'false',
                 'node_shared_v8': 'false',
                 'node_shared_zlib': 'false',
                 'node_tag': '',
                 'node_unsafe_optimizations': 0,
                 'node_use_dtrace': 'false',
                 'node_use_etw': 'false',
                 'node_use_openssl': 'true',
                 'node_use_perfctr': 'false',
                 'node_use_systemtap': 'false',
                 'python': '/usr/bin/python',
                 'target_arch': 'arm',
                 'v8_enable_gdbjit': 0,
                 'v8_no_strict_aliasing': 1,
                 'v8_use_arm_eabi_hardfloat': 'true',
                 'v8_use_snapshot': 'false'}}
creating  ./config.gypi
creating  ./config.mk


Step 4: Compile
We are ready to compile. It is going to take about a half-hour to complete — go get a cup of coffee.

# make


Step 5: Verify
Now that the build has finished, we can verify that all looks well before we install it.

# ./node -e 'console.log("het werkt!");'
# ./node -v


Step 6: Install
Now that all looks well, we are ready install it.

# make install
‹ Where to buy the BeagleBone BlackExpanding Linux Partitions: Part 1 of 2 ›
Posted in BeagleBone Black, HowTo	Tagged with: node debian ubuntu
